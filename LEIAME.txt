Arthur dos Santos Lima Gropp – GRR20211769

Inicialmente, eu testo os argumentos dados pelo usuário na execução de “beale”, por meio da biblioteca “testa_entrada”. Dessa forma verifico qual instrução meu programa deve executar (se deve encriptar com “-e” ou desencriptar com “-d”), e verifico também se foram passados todos os arquivos necessários para o funcionamento correto. Na sequência, podemos chegar em 3 diferentes casos: O primeiro seria o de encriptar. Para isso, utilizaremos a função “Analisa_Livro” para criar a nossa lista de chaves e códigos. A função em questão simplesmente pega linha por linha do Livro Cifra e chama para cada uma delas a função “identifica_chaves_livro”, que faz parte da biblioteca “gera_chaves”. Essa nova função, por sua vez, pega o primeiro caractere de cada string da linha e adiciona na lista de chaves a partir da função “add_lista”, que verifica se o caractere já está na lista, ou se ainda não está. Independentemente, ao final de tudo a chave estará na lista e seus respectivos códigos também. Para complementar a lista de chaves, há a chamada da função “add_demais_chaves”, que adiciona os demais caracteres que não puderam ser incluídos com base no Livro Cifra. Caracteres como números e letras são adicionados com códigos positivos, a partir do valor do último código adquirido. Caracteres como ponto de exclamação, vírgula e parênteses são adicionados com códigos negativos. Caso tenha sido passado um Arquivo de Chaves nos argumentos vindos da execução, o arquivo será preenchido com as chaves e seus respectivos códigos. Por fim, o arquivo Mensagem Original será lido e codificado caractere por caractere para dentro do arquivo Mensagem Codificada, por meio da lista anteriormente criada. O segundo caso seria o de desencriptar com base no Arquivo de Chaves. Para isso, salvamos cada chave e seus respectivos códigos, para então, por meio da função “identifica_chaves_arquivo”, montarmos nossa lista de chaves. Com a lista pronta, chamamos a função “Analisa_Mensagem_Codificada”, que simplesmente preenche um vetor com cada código encontrado na mensagem codificada, e caso se depare com uma quebra de linha atribui à posição referente a ela o valor -100, retornando por fim o tamanho do vetor resultante. Para finalizar, há a chamada da função 
“decodifica_mensagem”, onde ocorre a busca de um caractere que corresponda a cada valor do vetor anteriormente criado. A busca é realizada na lista de chaves e é uma busca binária. Assim que o caractere for encontrado ele é imprimido no arquivo que conterá a mensagem decodificada. O terceiro caso seria o de desencriptar com base no Livro Cifra. Para isso, simplesmente chamamos a função “Analisa_Livro”, seguida pela função “add_demais_chaves”, ambas anteriormente explicadas, mas que sucintamente falando, vão nos entregar a lista de chaves. Iremos então realizar a chamada da função “Analisa_Mensagem_Codificada”, que nos entregará o vetor com os valores a serem decodificados, e por fim, por meio do vetor e da lista vamos encontrar os caracteres correspondentes, a partir da função “decodifica_mensagem”.
